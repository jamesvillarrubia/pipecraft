# Action Decoupling: Summary & Recommendations

## What I've Created

I've created a complete strategy for decoupling PipeCraft actions from configuration file dependencies. Here's what's included:

### 1. **Decoupled Action Example**

📁 `.github/actions/promote-branch/action-decoupled.yml`

A refactored version of `promote-branch` that:

- ✅ Takes all config as inputs (no file reading)
- ✅ Works in any repository
- ✅ Can be published to GitHub Marketplace
- ✅ Easy to test independently

### 2. **Workflow Examples**

📁 `docs/examples/decoupled-workflow-example.yml`

Shows how to:

- Read config at workflow level (once)
- Pass values to decoupled actions
- Use actions without PipeCraft config
- Support manual workflow dispatch

### 3. **Comprehensive Guide**

📁 `docs/DECOUPLING_GUIDE.md`

Complete documentation covering:

- Architecture comparison (coupled vs decoupled)
- Migration strategy
- Testing approach
- Best practices
- FAQ

## Key Benefits

### For Action Users

- 🔄 **Reusable** - Actions work in non-PipeCraft projects
- 📦 **Publishable** - Can share on GitHub Marketplace
- 🧪 **Testable** - Easy to test with mock inputs
- 🎯 **Explicit** - Clear what inputs are needed

### For PipeCraft

- 🏗️ **Better Architecture** - Separation of concerns
- 🔧 **More Flexible** - Support multiple config formats
- 📈 **More Adoptable** - Actions can be used standalone
- 🚀 **Marketplace Ready** - Each action can have its own lifecycle

## Current State Analysis

### Already Decoupled ✅

- **`detect-changes`** - Takes `domains-config` as input (perfect!)

### Needs Decoupling ⚠️

- **`promote-branch`** - Reads `.pipecraftrc` for `branchFlow`
- **`calculate-version`** - May read config for versioning rules
- **`manage-branch`** - Check if reads config

### Already Generic ✅

- **`create-pr`** - Generic PR creation
- **`create-tag`** - Generic tag creation
- **`create-release`** - Generic release creation

## Recommended Approach

### Phase 1: Hybrid Transition (Backward Compatible)

Update actions to support **both** modes:

```yaml
inputs:
  targetBranch:
    description: 'Target branch (explicit mode)'
    required: false
  configPath:
    description: 'Config file (fallback mode)'
    required: false
    default: '.pipecraftrc'

steps:
  - name: Determine Target
    run: |
      if [ -n "${{ inputs.targetBranch }}" ]; then
        # New way: explicit input
        TARGET="${{ inputs.targetBranch }}"
      else
        # Old way: read from config
        TARGET=$(yq eval '.branchFlow[1]' ${{ inputs.configPath }})
      fi
```

**Benefits:**

- ✅ Existing workflows keep working
- ✅ New workflows can use explicit mode
- ✅ Gradual migration path

### Phase 2: PipeCraft Generates Decoupled Workflows

Update PipeCraft CLI to generate workflows that:

```yaml
# Generated by PipeCraft
jobs:
  prepare:
    outputs:
      targetBranch: ${{ steps.config.outputs.target }}
    steps:
      - name: Read PipeCraft Config
        id: config
        run: |
          # PipeCraft-generated logic to read .pipecraftrc
          TARGET=$(yq eval '.branchFlow[1]' .pipecraftrc)
          echo "target=$TARGET" >> $GITHUB_OUTPUT

  promote:
    needs: prepare
    steps:
      # Use decoupled action with values from config
      - uses: ./.github/actions/promote-branch
        with:
          targetBranch: ${{ needs.prepare.outputs.targetBranch }}
```

**Benefits:**

- ✅ PipeCraft still orchestrates everything
- ✅ Actions are reusable building blocks
- ✅ Best of both worlds

### Phase 3: Publish Actions (Optional)

Once stable, publish decoupled actions:

```yaml
- uses: pipecraft/promote-branch@v1
  with:
    sourceBranch: develop
    targetBranch: staging
```

## Implementation Checklist

### Immediate (Low Risk)

- [ ] Create `action-decoupled.yml` versions alongside existing
- [ ] Update documentation to show both approaches
- [ ] Test decoupled versions in non-PipeCraft repo

### Short Term

- [ ] Update `promote-branch` to hybrid mode
- [ ] Update PipeCraft CLI to generate workflows using decoupled pattern
- [ ] Add integration tests for decoupled actions

### Long Term

- [ ] Make decoupled mode the default
- [ ] Deprecate config-reading mode in actions
- [ ] Publish stable actions to Marketplace
- [ ] Version actions independently

## Example: Side-by-Side Comparison

### Current (Coupled)

```yaml
# Action reads config internally
- uses: ./.github/actions/promote-branch
  with:
    sourceBranch: develop
    configPath: .pipecraftrc # Action reads this
```

### Proposed (Decoupled)

```yaml
# Workflow reads config, action receives values
jobs:
  prepare:
    steps:
      - id: config
        run: |
          TARGET=$(yq eval '.branchFlow[1]' .pipecraftrc)
          echo "target=$TARGET" >> $GITHUB_OUTPUT
    outputs:
      targetBranch: ${{ steps.config.outputs.target }}

  promote:
    needs: prepare
    steps:
      - uses: ./.github/actions/promote-branch
        with:
          sourceBranch: develop
          targetBranch: ${{ needs.prepare.outputs.targetBranch }}
```

### Universal (No Config File)

```yaml
# Works without ANY config file!
- uses: ./.github/actions/promote-branch
  with:
    sourceBranch: develop
    targetBranch: staging
    autoMerge: false
```

## Questions to Consider

1. **Should decoupled actions be the default for new projects?**

   - Recommendation: Yes, with PipeCraft handling orchestration

2. **How to handle complex config like domain arrays?**

   - Already solved! `detect-changes` passes `domains-config` as input

3. **Should we version actions separately from PipeCraft?**

   - Yes, if publishing to Marketplace
   - No, if keeping them internal to generated projects

4. **Backward compatibility strategy?**
   - Hybrid mode during transition (support both)
   - Deprecation warnings in next major version
   - Remove coupled mode in v2.0

## Next Steps

1. **Review** this proposal with team
2. **Choose** phase 1 approach (hybrid transition)
3. **Prototype** with one action (promote-branch)
4. **Test** in real workflow
5. **Document** usage patterns
6. **Roll out** to other actions

## Files Created

```
.github/actions/promote-branch/
└── action-decoupled.yml          # Refactored decoupled version

docs/
├── DECOUPLING_GUIDE.md            # Comprehensive guide
└── examples/
    └── decoupled-workflow-example.yml  # Usage examples

DECOUPLING_SUMMARY.md              # This file
```

## Conclusion

Decoupling actions from PipeCraft configuration is:

- ✅ **Feasible** - Clear implementation path
- ✅ **Beneficial** - Increases reusability and testability
- ✅ **Backward Compatible** - Can be done gradually
- ✅ **Aligned** - With GitHub Actions best practices

The hybrid approach allows you to maintain existing workflows while enabling new possibilities like Marketplace publishing and non-PipeCraft usage.

---

**Recommendation:** Start with Phase 1 (hybrid transition) for `promote-branch` action, test thoroughly, then expand to other actions.
