name: 'Promote Branch'
description: 'Promote code from source to target branch via temporary branch + PR - fully decoupled, no config file dependencies'
author: 'PipeCraft'

inputs:
  sourceBranch:
    description: 'Source branch to promote from'
    required: true
  targetBranch:
    description: 'Target branch to promote to'
    required: true
  version:
    description: 'Version being promoted (e.g., v1.2.3, auto-detected from git tags if not provided)'
    required: false
    default: ''
  autoMerge:
    description: 'Whether to automatically fast-forward merge (true) or require manual approval (false)'
    required: false
    default: 'false'
  runNumber:
    description: 'The original run number from source branch for traceability'
    required: false
    default: ''
  tempBranchPattern:
    description: 'Pattern for temp branch name (supports {source}, {target}, {version} tokens)'
    required: false
    default: 'release/{source}-to-{target}-{version}'
  token:
    description: 'GitHub token for authentication'
    required: false
    default: ${{ github.token }}

outputs:
  prNumber:
    description: 'The created PR number'
    value: ${{ steps.check-pr.outputs.prNumber || steps.create-pr.outputs.prNumber }}
  prUrl:
    description: 'The created PR URL'
    value: ${{ steps.check-pr.outputs.prUrl || steps.create-pr.outputs.prUrl }}
  tempBranch:
    description: 'The temporary branch name'
    value: ${{ steps.create-temp.outputs.tempBranch }}

runs:
  using: 'composite'
  steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ inputs.token }}

    - name: Validate Inputs
      shell: bash
      run: |
        SOURCE="${{ inputs.sourceBranch }}"
        TARGET="${{ inputs.targetBranch }}"
        
        if [ -z "$SOURCE" ]; then
          echo "‚ùå sourceBranch is required"
          exit 1
        fi
        
        if [ -z "$TARGET" ]; then
          echo "‚ùå targetBranch is required"
          exit 1
        fi
        
        if [ "$SOURCE" == "$TARGET" ]; then
          echo "‚ùå sourceBranch and targetBranch cannot be the same"
          exit 1
        fi
        
        echo "‚úÖ Inputs validated"
        echo "   Source: $SOURCE"
        echo "   Target: $TARGET"
        echo "   Auto-merge: ${{ inputs.autoMerge }}"

    - name: Get Version
      id: get-version
      shell: bash
      run: |
        VERSION_INPUT="${{ inputs.version }}"

        if [ -n "$VERSION_INPUT" ]; then
          VERSION="$VERSION_INPUT"
          echo "üìå Using provided version: $VERSION"
        else
          # Auto-detect from git tags
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
          echo "üè∑Ô∏è  Auto-detected version from tags: $VERSION"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Create Temporary Branch
      id: create-temp
      shell: bash
      run: |
        SOURCE="${{ inputs.sourceBranch }}"
        TARGET="${{ inputs.targetBranch }}"
        VERSION="${{ steps.get-version.outputs.version }}"
        PATTERN="${{ inputs.tempBranchPattern }}"

        # Remove 'v' prefix from version for branch name
        VERSION_CLEAN="${VERSION#v}"

        # Replace placeholders in pattern
        TEMP_BRANCH="$PATTERN"
        TEMP_BRANCH="${TEMP_BRANCH//{source\}/$SOURCE}"
        TEMP_BRANCH="${TEMP_BRANCH//{target\}/$TARGET}"
        TEMP_BRANCH="${TEMP_BRANCH//{version\}/$VERSION_CLEAN}"

        echo "üåø Preparing temporary branch: $TEMP_BRANCH"
        echo "   From: $SOURCE"
        echo "   To: $TARGET"
        echo "   Version: $VERSION"

        # Ensure we're on the source branch
        git checkout "$SOURCE"

        # Check if temp branch already exists locally or remotely
        if git show-ref --verify --quiet refs/heads/"$TEMP_BRANCH" || git ls-remote --heads origin "$TEMP_BRANCH" | grep -q "$TEMP_BRANCH"; then
          echo "‚ö†Ô∏è  Temp branch $TEMP_BRANCH already exists, using existing branch"
          # Fetch and checkout existing branch
          git fetch origin "$TEMP_BRANCH" 2>/dev/null || true
          git checkout "$TEMP_BRANCH" 2>/dev/null || git checkout -b "$TEMP_BRANCH" origin/"$TEMP_BRANCH"
        else
          echo "üìù Creating new temp branch $TEMP_BRANCH"
          # Create temp branch from current commit
          git checkout -b "$TEMP_BRANCH"
          # Push temp branch to remote
          git push origin "$TEMP_BRANCH"
        fi

        echo "tempBranch=$TEMP_BRANCH" >> $GITHUB_OUTPUT
        echo "‚úÖ Temporary branch ready"

    - name: Check for Existing PR
      id: check-pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        TEMP_BRANCH="${{ steps.create-temp.outputs.tempBranch }}"
        TARGET="${{ inputs.targetBranch }}"

        # Check if PR already exists from temp branch to target
        EXISTING_PR=$(gh pr list --head "$TEMP_BRANCH" --base "$TARGET" --json number,url --jq '.[0] | {number, url}' 2>/dev/null || echo "")

        if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
          PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
          PR_URL=$(echo "$EXISTING_PR" | jq -r '.url')
          
          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "prNumber=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "prUrl=$PR_URL" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  PR already exists: #$PR_NUMBER"
            echo "üîó URL: $PR_URL"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No existing PR found"
          fi
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚úÖ No existing PR found"
        fi

    - name: Create Pull Request
      id: create-pr
      if: steps.check-pr.outputs.exists == 'false'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        TEMP_BRANCH="${{ steps.create-temp.outputs.tempBranch }}"
        TARGET="${{ inputs.targetBranch }}"
        SOURCE="${{ inputs.sourceBranch }}"
        VERSION="${{ steps.get-version.outputs.version }}"
        AUTO_MERGE="${{ inputs.autoMerge }}"

        TITLE="üöÄ Release $VERSION to $TARGET"
        
        # Build body with promotion details
        BODY="## Automated Promotion

**Version:** \\\`$VERSION\\\`
**Source:** \\\`$SOURCE\\\`
**Target:** \\\`$TARGET\\\`

---

This PR promotes code from \\\`$SOURCE\\\` to \\\`$TARGET\\\` for release \\\`$VERSION\\\`.

"
        if [ "$AUTO_MERGE" == "true" ]; then
          BODY+="üîÑ **Auto-merge:** Enabled - will fast-forward merge automatically"
        else
          BODY+="üîê **Manual approval:** Required before merge"
        fi

        # Disable error exit to capture gh pr create output even on failure
        set +e

        # Create the PR - gh pr create returns the PR URL on success
        PR_URL=$(gh pr create \
          --title "$TITLE" \
          --body "$BODY" \
          --head "$TEMP_BRANCH" \
          --base "$TARGET" 2>&1)
        PR_EXIT_CODE=$?

        # Re-enable error exit
        set -e

        if [ $PR_EXIT_CODE -eq 0 ] && [[ "$PR_URL" =~ ^https://github.com/.*/pull/[0-9]+$ ]]; then
          # Extract PR number from URL (e.g., https://github.com/owner/repo/pull/123)
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "prNumber=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "prUrl=$PR_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Created PR #$PR_NUMBER"
          echo "üîó URL: $PR_URL"
        else
          echo "‚ùå Failed to create PR"
          echo "Error output:"
          echo "$PR_URL"
          exit 1
        fi

    - name: Enable PR Auto-Merge with Rebase (Manual Approval Required)
      if: inputs.autoMerge == 'false'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        PR_NUMBER="${{ steps.check-pr.outputs.prNumber || steps.create-pr.outputs.prNumber }}"
        TARGET="${{ inputs.targetBranch }}"

        echo "üîê Enabling auto-merge with rebase for PR #$PR_NUMBER (requires approval)"
        echo "   This will fast-forward $TARGET when approved, maintaining linear history"

        # Enable auto-merge with rebase method (fast-forward, no merge commit)
        gh pr merge "$PR_NUMBER" --auto --rebase

        echo "‚úÖ Auto-merge enabled - PR will fast-forward merge when approved"
        echo "‚ö†Ô∏è  Manual approval required before merge completes"

    - name: Fast-Forward Merge (Immediate Auto-Merge)
      if: inputs.autoMerge == 'true'
      shell: bash
      run: |
        SOURCE="${{ inputs.sourceBranch }}"
        TARGET="${{ inputs.targetBranch }}"
        VERSION="${{ steps.get-version.outputs.version }}"

        echo "üöÄ Fast-forwarding $TARGET to $SOURCE (maintaining linear history)"

        # Get the commit SHA from source branch
        COMMIT_SHA=$(git rev-parse $SOURCE)
        echo "Source commit: $COMMIT_SHA"

        # Fetch target branch
        git fetch origin $TARGET:$TARGET 2>/dev/null || true

        # Checkout target branch
        git checkout $TARGET

        # Verify we can fast-forward (no divergent commits)
        if git merge-base --is-ancestor $TARGET $SOURCE; then
          echo "‚úÖ Fast-forward is possible (linear history maintained)"
        else
          echo "‚ùå Cannot fast-forward - branches have diverged"
          echo "Target branch has commits not in source branch"
          exit 1
        fi

        # Fast-forward merge (no merge commit)
        git merge --ff-only $SOURCE

        # Push to remote
        git push origin $TARGET

        echo "‚úÖ Fast-forwarded $TARGET to $COMMIT_SHA"
        echo "üìù PR will be closed automatically for audit trail"

    - name: Wait for Branch to Propagate
      if: inputs.autoMerge == 'true'
      shell: bash
      run: |
        echo "‚è≥ Waiting 5 seconds for branch update to propagate..."
        sleep 5
        echo "‚úÖ Branch should be fully propagated"

    - name: Trigger Pipeline Workflow on Target Branch
      if: inputs.autoMerge == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        TARGET="${{ inputs.targetBranch }}"
        VERSION="${{ steps.get-version.outputs.version }}"
        RUN_NUMBER="${{ inputs.runNumber }}"

        # Get the exact commit SHA that was just pushed to target branch
        COMMIT_SHA=$(git rev-parse $TARGET)
        echo "üîÑ Triggering pipeline workflow on $TARGET branch"
        echo "   Version: $VERSION"
        echo "   Commit SHA: $COMMIT_SHA"

        # Trigger the pipeline workflow on the target branch
        # This is necessary because GITHUB_TOKEN pushes don't trigger workflows by default
        # Pass the exact commit SHA to ensure the workflow checks out the correct commit
        # (avoids race conditions from GitHub's eventual consistency)
        WORKFLOW_ARGS=(--ref "$TARGET" --field version="$VERSION" --field commitSha="$COMMIT_SHA")
        if [ -n "$RUN_NUMBER" ]; then
          WORKFLOW_ARGS+=(--field run_number="$RUN_NUMBER")
          echo "   Run number: $RUN_NUMBER (for traceability)"
        fi

        gh workflow run pipeline.yml "${WORKFLOW_ARGS[@]}"

        echo "‚úÖ Pipeline workflow triggered on $TARGET with version $VERSION at commit $COMMIT_SHA"

    - name: Close PR and Delete Branch
      if: inputs.autoMerge == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        TEMP_BRANCH="${{ steps.create-temp.outputs.tempBranch }}"
        PR_NUMBER="${{ steps.check-pr.outputs.prNumber || steps.create-pr.outputs.prNumber }}"

        echo "üßπ Cleaning up temporary branch: $TEMP_BRANCH"

        # Close the PR (it's already been fast-forward merged)
        if [ -n "$PR_NUMBER" ]; then
          gh pr close "$PR_NUMBER" --comment "Automatically merged via fast-forward. Closing PR and cleaning up release branch." || true
          echo "‚úÖ Closed PR #$PR_NUMBER"
        fi

        # Delete the temporary branch from remote
        git push origin --delete "$TEMP_BRANCH" || echo "‚ö†Ô∏è  Branch may already be deleted"

        echo "‚úÖ Deleted temporary branch $TEMP_BRANCH"
